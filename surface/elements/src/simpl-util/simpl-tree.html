<polymer-element name="simpl-tree" attributes="selectedItem data idProp childrenProp nameProp">
	<template>
		<style>
			div[id] {
				cursor: pointer;
			}
			span[selected] {
				color: #fc0 !important;
				font-weight: bold;
			}
			ul {
				margin: 0;
				padding-left: 20px;
			}
			li {
				list-style-type: none;
			}
			.truncate {
				padding-top: 6px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			polyfill-rule {
				content: '.truncate';
				width: calc(100% - 28px);
				padding-top: 3px;
			}
			tree-icon {
				display: inline-block;
				vertical-align: middle;
				background-repeat: no-repeat;
				fill: currentcolor;
				position: relative;
				height: 24px;
				width: 24px;
			}

		</style>
		<div id="main" unresolved="">
			<template id="tree_template" bind="{{data as d}}">
				<div layout horizontal id="{{d[idProp]}}" class="{{ d.children && d.children.length > 0 ? 'parent' : ''}} collapsed" on-click="{{selectItem}}">
					<tree-icon on-click="{{toggleChildren}}" icon="{{ d.children && d.children.length > 0 ? 'hardware:keyboard-arrow-right' : 'arrow-drop-dowx'}}"></tree-icon>
					<span title="{{d[nameProp]}}" class="truncate" style="color:{{d.children && d.children.length > 0 ? 'black' : 'gray'}}">{{ d[nameProp] }}</span>
				</div>
				<ul style="display:none;">
					<template repeat="{{ child in d.children }}">
						<li>
							<template ref="tree_template" bind="{{child as d}}"></template>
						</li>
					</template>
				</ul>
			</template>
		</div>
	</template>
	<script>
		Polymer( 'simpl-tree', {
			iconOpen: 'hardware:keyboard-arrow-right',
			iconClose: 'hardware:keyboard-arrow-down',
			iconBOM: 'arrow-drop-down',
			data: {},
			idProp: 'path',
			childrenProp: 'children',
			nameProp: 'name',
			toggleChildren: function( e, detail, sender ) {
				e.preventDefault();
				e.stopPropagation();
				var target = e.target || e.srcElement;
				var div = target.parentNode;
				var icon = target;
				if ( div.className.indexOf( 'parent' ) > -1 && div.nextElementSibling ) {
					var current_display = div.nextElementSibling.style.display;
					if ( current_display === 'none' ) {
						div.className = 'parent expanded';
						div.nextElementSibling.style.display = 'block';
						icon.setIcon( this.iconClose );
					} else {
						div.className = 'parent collapsed';
						div.nextElementSibling.style.display = 'none';
						icon.setIcon( this.iconOpen );
					}
				}
			},
			selectItem: function( e, detail, sender ) {
				var target = e.target || e.srcElement;
				var span = target;
				target = target.parentNode;
				var id = target.getAttribute( "id" );
				if( id == null) return;

				if ( this.prevSelected ) {
					this.prevSelected.removeAttribute( "selected" );
				}
				this.selectedItem = this.getNodeById( id, this.data );
				span.setAttribute( "selected", "" );
				this.prevSelected = span;
				console.log( "selectedItem:", this.selectedItem );
			},
			getNodeById: function( id, node ) {
				if ( node[this.idProp] == id ) {
					return node
				}
				var children = node[this.childrenProp];
				for ( var i = 0; children && i < children.length; i++ ) {
					var node = this.getNodeById( id, children[ i ] );
					if ( node ) return node;

				}
				return null;
			},
			created: function() {},

			domReady: function() {},

			ready: function() {
				this.$.main.setAttribute( 'resolved', '' );
				this.$.main.removeAttribute( 'unresolved' );
			},

			attached: function() {},

			detached: function() {},

			attributeChanged: function( attr, oldVal, newVal ) {}
		} );

	</script>

</polymer-element>
